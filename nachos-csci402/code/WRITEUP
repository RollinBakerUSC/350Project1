Title:  Writeup for Project 3, Fall 2015
Date:  11/01/15
Group:        Rollin Baker        rollinba@usc.edu        
                Sloan Swieso        swieso@usc.edu        
                Jiwoo Kim        jiwookim@usc.edu        

*Note: If there is trouble compiling, please see the miscellaneous section*
I. Requirements:


For Project 3, we are required to expand upon our memory management system from Project 2 and implement Demand-Paged Virtual Memory. This means that an arbitrary number of programs can be running in memory at any given time, and each of these programs can be larger than the entire physical main memory. We are also required to convert all of our system calls from Project 2 into RPCs that communicate across a network to different nachos ?machines?. We are given a ?Post Office? abstraction for message passing and must build on it to create a reliable messaging service.


For Part 1, we need to set up a Translation Lookaside Buffer, which is basically the highest level cache for virtual pages. For Part 2, we begin to implement our virtual memory scheme by creating the IPT, the swap file, and mechanisms for moving data between disk and memory. After Part 2 is finished, we should be able to run multiple programs that are each larger than our physical memory. Finally, for Part 3, we establish a mechanism for communicating between different nachos instances. The provided Post Office abstraction provides the framework for this, and we must upgrade it to handle RPCs for locks and condition variables, which will be converted from our Project 2 syscalls. We must also implement RPCs for managing monitor variables.

II. Assumptions:
        We used a byte as our smallest unit of message passing. As result, several values can reach a maximum value of 255. This includes the number of locks that the server can hold, the number of CVs that the server can hold, the maximum number of MVs the server can hold, and the maximum value of any element of an MV array.
NumPhysPages is back to 32.

III. Design:

Part 1:
We added an else if statement to ExceptionHandler() in exception.cc to handle a PageFaultException type exception. The else if statement then called the HandlePageFault() function also within exception.cc. HandlePageFault() calculates the virtual page number (vpn) that was a miss in the TLB by reading the BadVAddrReg and dividing it by PageSize. Then HandlePageFault() calls the newly added updateTLB function from within exception.cc.


The updateTLB function takes in an integer argument that represents the physical page number of the translation entry that is to be added to the TLB. First, this function checks if the TLB entry we are about to overwrite is dirty. If it is dirty then we propagate the dirty bit to the IPT. Then the function sets all the values in the proper TLB entry corresponding values of the entry at the physical page number in the IPT.


In order to keep track of the current TLB entry, which needs to be overwritten once a PageFaultException occurs, we added a global int variable in system.h and system.cc called currentTLB. After overwriting an entry in the TLB, currentTLB is incremented and then modded by the TLBSize so that it acts as a FIFO policy.


Part 2:
For the second part, we needed to implement the inverse page table. An IPT entry is nearly identical to a page table entry, except that an IPT entry must also track the owners of its stored pages. To implement this, we created an IPTEntry struct with two member: an instance of a TranslationEntry object and a pointer to an address space (to indicate the process that owns a page). We instantiate the IPT as an array of size NumPhysPages. The IPT starts off as empty, because we do not preload anything into main memory.


On a PageFaultException where the needed entry is not in the IPT, we call the HandleIPTMiss() function from within exception.cc. There we use a BitMap::find() which represents space in main memory to allocate physical pages. If the find returns a -1, then we have to evict a page from main memory to make room for the page we need. To do this, we call the HandleMemoryFull() function from within exception.cc.


Depending on the page replacement policy determined by the flags -P RAND and -P FIFO, HandleMemoryFull() selects a page from main memory to evict. We must also account for the possibility that a page was modified during program execution. If that happened, then nachos will have flagged the ?dirty? bit on the page in the TLB. Since we can?t write the modification back into the executable, we have to store it in a separate location on the hard disk, called the ?swap file?. The swap file holds all dirty pages that cannot be written back into the executable. However, at this point we now have three possible locations for a page on a TLB miss: the IPT (memory), the executable, or the swap file. We need to keep track of each page?s location, and we do this in the page table for the process that owns the page. When looking for a page, the memory management unit will at some point need to access this information so it knows where to read the page from. After locating where the page in main memory needs to be evicted to, if it is the swap file that page finds an open spot in the swap file using the swapFileBitMap and writes the page to the swap file. If the main memory page we are evicting was not dirty, we do not write it back anywhere, but keep track of whether it is in the executable or neither. After evicting the physical page, we return to HandleIPTMiss().


After finding the physical page that was either open or evicted, HandleIPTMiss() in exception.cc calls IPTMiss() in the AddrSpace instance of the currentThread. Here in IPTMiss() in the AddrSpace class, the page in main memory that we are writing to is zeroed out. Then data that we need is brought into the open page in main memory using a ReadAt from either the swap file or the executable. Then, the page table entry in the AddrSpace?s pageTable member is updated to show this new physical page and that it is valid. Then, the IPT entry at this physical page number is updated to keep track of the owner and the virtual page number.


Only after all the above steps is the TLB updated using the updateTLB function from within exception.cc as explained earlier.




Part 3:
For the networking part, we must implement the server code and change our system calls accordingly so that they can receive and send messages with the server. The server will be a standalone void function that runs forever. The server will receive messages and decode it to get the instruction and its parameters. Then the server will use those information to do the job and reply back to the clients. The networking must implement functions for locks, conditions, and monitor variables.

We used the following message format for communicating between a client and server
First byte is always the opcode. After reading the opcode, the program branches to properly parse the rest of the mail. Each field is assumed to be one byte wide unless otherwise stated. Our server is in a constant while(true) loop, and receives a new message from a client on every iteration. The server reads in the request byte by byte and takes appropriate action as described in the implementation section further below.


CreateLock(int size, char* name) request from client:
<Opcode = 0><Length of Lock name  ><Lock name ><Don?t Care (last 37 bytes)>
CreateLock reply from server:
<Lock index ><Don?t care(last 39 bytes)>


Acquire(int lockIndex) request from client:
<Opcode = 1 ><Lock index ><Don?t care (last 38 bytes)>
Acquire reply from server:
<Acknowledge><Rest are don?t-cares>


Release(int lockIndex) request from client:
<Opcode = 2 ><Lock index ><Don?t care (last 38 bytes)>
Release reply from server:
<Acknowledge><Rest are don?t-cares>


DestroyLock(int lockIndex) request from client:
<Opcode = 3 ><Lock index ><Don?t care (last 38 bytes)>
DestroyLock reply from server:
<Acknowledge><Rest are don?t-cares>


CreateCV(int size, char* name) request from client:
<Opcode = 4 ><Length of CV name ><CV name ><Don?t Care (last 37 bytes)>
CreateCV reply from server:
<CV index ><Don?t care(last 39 bytes)>


Signal(int CVIndex, int lockIndex) request from client:
<Opcode = 5 ><CV index ><Lock index ><Don?t Care (last 37 bytes)>
Signal reply from server:
<Acknowledge><Rest are don?t-cares>


Broadcast(int CVIndex, int lockIndex) request from client:
<Opcode = 6 ><CV index ><Lock index ><Don?t Care (last 37 bytes)>
Broadcast reply from server:
<Acknowledge><Rest are don?t-cares>


Wait(int CVIndex, int lockIndex) request from client:
<Opcode = 7 ><CV index ><Lock index ><Don?t Care (last 37 bytes)>
Wait reply from server: (does not come immediately, waits to send until someone signals)
<Acknowledge><Rest are dont-cares>


DestroyCV(int CVIndex) request from client:
<Opcode = 8 ><CV index ><Don?t care (last 38 bytes)>
DestroyCV reply from server:
<Acknowledge><Rest are don?t-cares>


CreateMV(int size, char* name, int numElements) request from client:
<Opcode = 9><Length of MV name><MV name (variable size)><NumElements><Don?t Cares>
CreateMV reply from server:
<MV index><Don?t care(last 39 bytes)>


SetMV(int MVIndex, int arrayIndex, int value) request from client:
<Opcode = 10><MVIndex><ArrayIndex><Value><Don?t Care (last 36 bytes)>
SetMV reply from server:
<Acknowledge><Don?t care (last 39 bytes)>


GetMV(int MVIndex, int arrayIndex) request from client:
<Opcode = 11><MVIndex><ArrayIndex><Don?t Care (last 37 bytes)>
GetMV reply from server:
<MV Value><Don?t care (last 39 bytes>


DestroyMV(int MVIndex) request from client:
<Opcode = 12 ><MV index ><Don?t care (last 38 bytes)>
DestroyMV reply from server:
<Acknowledge><Don?t care (last 39 bytes)>

IV. Implementation:
        + Files Modified
                nettest.cc
                system.h
                system.cc
                main.cc
                addrspace.cc
                addrspace.h
                exception.cc
                Makefile
                start.s
                syscall.h
                


        + Files added
                lockandcvs.c
                test_broadcast.c
                test_broadcast_wait.c
                test_locks.c
                

        + Data Structures added, and the file they were added to.
                        struct IPTEntry{        in system.h
                             TranslationEntry entry;
                             AddrSpace* owner;
                        };






                struct ServerLock {        in nettest.cc
                        ServerLock(char* _name) {
                                owner = -1;
                                available = true;
                                ownerMailBoxNum = 1;
                                waitQueue = new List();
                                name = _name;
                                numWaiters = 0;
                                toBeDeleted = false;
                        }
                        int owner;
                        bool available;
                        int ownerMailBoxNum;
                        List* waitQueue;
                        char* name;
                        int numWaiters;
                        bool toBeDeleted;
                }


                struct ServerCV {        in nettest.cc
                        ServerCV(char* _name) {
                                serverLockIndex = -1;
                                waitQueue = new List();
                                name = _name;
                                toBeDeleted = false;
                                numWaiters = 0;
                        }
                        int serverLockIndex;
                        List* waitQueue;
                        char* name;
                        bool toBeDeleted
                        int numWaiters
                }


                struct ServerMV{        in nettest.cc
                        ServerMV(int size, char* _name) {
                                values = net int[size];
                                for(int i = 0; i < size; i++) {
                                        values[i] = 0;
                                }
                                name = _name;
                                numElements = size;
                        }
                        int* values;
                        char* name;
                        int numElements;
                }


                struct ReplyMessage{        in nettest.cc
ReplyMessage(int id, int box, char* msg, int length){
        DestID = id;
        DestBox = box;
        replyMsg = msg;
        size = length;
} 
                        int DestID;
                        int DestBox;
                        int size;
                        char* replyMsg;
                }

        + Data Structures modified, and the file they were added to.
                -For example,
                        class Lock                -- in file threads.cc/threads.h
                        {
                                //. Modified fields.
                        }


class AddrSpace {        in addrspace.cc/h
        changed constructor function
        changed SaveState() function
        changed clearMem() function
        added setTLB function
        added IPTMiss function
        added swappedPage function
        added evictedPage function
        removed TranslationEntry
        added PageTableEntry
        added executable
        changed clearMem function
        changed clearStack function
        changed allocateStack function
}






        + Functions added and in which file.
                void HandlePageFault() {        exception.cc
                        disable interrupts
                        read vpn at register BadVaddrReg/PageSize;
                        acquire IPTLock
                        int ppn = -1
                        for all NumPhysPages
                                if IPT vpn equals vpn above
                                        set ppn to be IPT?s ppn at that index
                        if ppn is still -1
                                ppn = HandleIPTMiss(vpn)
                        updateTLB(ppn)
                        release IPTLock
                        restore interrupts
                }


                int CreateMV_Syscall(int vaddr, int length, int size) {        in exception.cc
                        create chars for request and response
                        set the outgoing packet and mail header
                        put the op code and lock index to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive a response from the server
                        return the first byte of this response (will be index of MV)


                }


                void DestroyMV_Syscall(int index) {        in exception.cc
                        create chars for request and response
                        set the outgoing packet and mail header
                        put the op code and lock index to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive an OK response from the server
                }


                void SetMV_Syscall(int index, int position, int var) {        in exception.cc
create chars for request and response
                        set the outgoing packet and mail header
put the op code, MV index, offset into MV array and value to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive an OK response from the server
                }


                int GetMV_Syscall(int index, int position) {        in exception.cc
create chars for request and response
                        set the outgoing packet and mail header
                        put the op code, MV index and offset into MV array to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive a response from the server
return the first byte of the response (will be the value of the desired MV)
                }


                int CreateLock(char* lockName) {        nettest.cc
                        create a new serverlock with argument
                        push the new serverlock to serverlock table
                        return the index of the lock in table
                }


                int DestroyLock(int index) {        in nettest.cc
                        check the index validity
                        find the lock to be deleted in lock table
                        check its number of waiting threads and availability
                        delete if it meets the requirement
                        otherwise just set its toBeDeleted bool to true;
                }


                bool Acquire(int index) {        in nettest.cc
                        check index validity
                        get the lock to acquire
                        acquire it only if it is available
                }


                void Release(int index) {        in nettest.cc
                        check index validity
                        get the lock at that index
                        make sure the lock is not NULL
                        if the lock?s numWatiers is greater than 0
                                decrement numWaiters
                                create a new ReplyMsg to remove from the lock?s waitQueue
                                set outgoing packet and mail header
                                call postOffice->Send with new ReplyMsg?s response message
                                delete the new ReplyMsg
                        if lock is to be deleted
                                delete the lock
                        else set the lock?s owner to -1 and make it available
                }


                int CreateCV(char* name) {        in nettest.cc
                        create a new ServerCV and add it to ServerCVTable
                        return the index
                }


                void Signal(int condIndex, int lockIndex) {        in nettest.cc
                        check index validity
                        if the lock index matches, decrement the numWaiters on the CV
                        make a new ReplyMsg on the CV?s waitQueue front element
                        increment the lock?s numWaiters
                        add the ReplayMsg to lock?s waitQueue
                        delete the CV if it doesn?t have waiters
                }


                void Broadcast(int cvIndex, int lockIndex) {        in nettest.cc
                        check index validity
                        get the CV
                        while numWaiters positive
                                decrement CV?s numWaiters
                                create ReplyMsg on waitingQueue element
                                increment the lock?s numWaiters associated with the CV
                                append to that lock?s waitQueue
                        destroy the CV
                }


                void Wait(int cvIndex, int lockIndex) {        in nettest.cc
                        get the CV at cvIndex
                        get the lock at lockIndex
                        if the CV?s numWaiters is positive
                                decrement numWaiters
                                create ReplyMsg on CV?s waitQueue element
                                set packet and mail header
                                call postOffice->Send with new reponse of ReplyMsg
                        else set the CV?s owner to -1 and make it available
                }


                void DestroyCV(int index) {        in nettest.cc
                        check index validity
                        if the CV has no waiters, just delete it
                        if it has waiters, set its toBeDeleted to true
                }


                int CreateMV(char* mvName, int numElements) {        in nettest.cc
                        create a new ServerMV with given name and number of elements
                        push it back to the table
                        return the index
                }


                void SetMV(int index, int arrayIndex, int value) {        in nettest.cc
                        check index validity
                        check arrayIndex validity
                        set the value of MV at index to the given value
                }




                void GetMV(int index, int arrayIndex) {        in nettest.cc
                        check index validity
                        check arrayIndex validity
                        return the value of MV at the correct index
                }


                void DestroyMV(int index) {        in nettest.cc
                        check index validity
                        annihilate the MV at that index
                }


                void Server {        in nettest.cc
                        initialize outgoing packet and mail header
initialize char* for request and reply message
initialize index, machineID, length, CV index and lock index.
while (true) {
set request to 0
call postOffice->Receive to receive request from clients
get the OPCODE which is the first char of reuqest message
switch(OPCODE) {
case 0: CreateLock case
get the name length from request message
get the lock name from request message
call CreateLock and get the index
set the outgoing packet and mail header
call postOffice->Send to outgoing address with index


case 1: Acquire case
get the index from request message
call Acquire
set outgoing packet and mail header
if Acquire is true
        set the lock?s owner to client
        postOffice->Send to the client
if Acquire is false
        create a new ReplyMsg with client info
        increment the numWaiters for the lock
        append to the waitQueue of lock


case 2: Release case
get the index from the request message
if the owner matches, release the lock
else don?t release it
set outgoing packet and mail header
call postOffice->Send with a response message


case 3: DestroyLock case
get the index of lock from request message
call DestroyLock(index)
set outgoing packet and mail header
call postOffice->Send with success message


case 4: CreateCV
get the name from the request message
call CreateCV to create a CV and get an idnex
set outgoing packet and mail header
call postOffice->Send with index


case 5: Signal
get both CV and lock index from request message
check index validity and call Signal
set outgoing packet and mail header
call postOffice->Send with dummy success message


case 6: Broadcast
get CV and lock index from request message
check index validity
call Broadcast
set outgoing packet and mail header
call postOffice->Send with response message


case 7: Wait
get CV and lock index from the request message
check validity and call Wait
set outgoing packet and mail header
create a new ReplyMsg with header info and response
increment numWaiters for the CV and append the reply


case 8: DestroyCV
get the index from request message
call DestroyCV
set outgoing packet and mail header
call postOffice->Send with success response






case 9: CreateMV
get the name of MV, length of name, and numElements
from the request messsage
call CreateMV with those info
set outgoing packet and mail header
call postOffice->Send with response that contains mvIndex


case 10: SetMV
get index, arrayIndex, and value from request message
call SetMV with those info
set outgoing packet and mail header
call postOffice->Send with success response message


case 11: GetMV
get the index and arrayIndex from request message
call GetMV with those info and to get the return value
set outgoing packet and mail header
call postOffice->Send with response that has return value


case 12: DestroyMV
get index from the request message
call DestroyMV with that index
set outgoing packet and mail header
call postOffice->Send with success response message
}
                        }
                }


void AddrSpace::setTLB(int vpn) {         in addrspace.cc
                        disable interrupts
                        hard copy pageTable of vpn to machine TLB
                        enable interrupts
}


void AddrSpace::IPTMiss(int vpn, int ppn) {        in addrspace.cc
                        check if the index vpn is in executable
                                read it
                        check if index vpn is in swapfile
                                read it
                        set pageTable index vpn entry to true and set its physical page to ppn
                        set the variables of IPT entry in index ppn
                                vpn, ppn, valid/use/dirty/readonly bit, and owner
}


void AddrSpace::swappedPage(int vpn, int swapLocation) {        in addrspace.cc
                        set pageTable at index vpn valid false
                        set its location to 0
                        set its swapLocation to be the new swapLocation passed in
}


void updateTLB(int ppn) {        in exception.cc
                acquire TLBLock
                if current TLB is dirty, set IPT dirty to be dirty
                set current TLB data and bits to be IPT data and bits at index ppn
                release TLBLock
        }


        int HandleMemoryFull() {        in exception.cc
                get a random physical page
                check if the owner is same as current thread?s
                find the TLB physical page that is the randomly chosen physical page
                        set its valid bit to false and match TLB and IPT dirty bit
                check if IPT bit is dirty at index ppn
                        find a swapLocation and write to it the main memory of ppn
                        change IPT?s owner to swappedPage at index ppn
                if IPT bit is not dirty, set IPT?s owner to evictedPage at index ppn
                return ppn
        }
                

        + Functions modified and in which file.


                void Initialize(int argc, char **argv) {        in system.cc
                        set the current TLB
                        set the swap file
                        set the bitmap and lock associated with the swap file


                        set the IPTEntry
                        set the TLB Lock
                }


                void Cleanup() {         in system.cc
                        added deletes for swapfile and its bitmap and lock
                }


                AddrSpace::AddrSpace {        in addrspace.cc
                        removed the Project 2 implementation of finding memory through bitMap
                        set pageTable?s entry vpn, valid, use, dirty, and readonly bit
                        set pageTable?s byteOffset and location
                }


                void AddrSpace::SaveState() {        in addrspace.cc
                        disable interrupt
                        acquire TLBLock
                        set machine TLB valid bit
                        release TLB lock
                        restore interrupt
                }


                void AddrSpace::clearMem() {        in addrspace.cc
                        instead of using pageTable index, use pageTable index?s entry
                        set IPT of pageTable entry valid to false
                        set pageTable entry valid to false
                }


                void AddrSpace::clearStack(int stack) {        in addrspace.cc
                        instead of using pageTable Index, use the entry
                        set IPT valid to false
                }


                void AddrSpace::allocateStack() {        in addrspace.cc
                        instead of using pageTable, use pageTable entry
                }


                void ExceptionHandler(ExceptionType which) {        in exception.cc
                        added an else if to catch PageFaultException
                        when caught, call HandlePageFault()


                        added swtich cases for monitor functions with syscall exception
                }
                
                int CreateLock_Syscall(int vaddr, int size) {        in exception.cc
                        check lock name validity
                        create new char for request and response
                        Hard set the outgoing packet and mail header to the server
                        put the op code and lock name into request message
                        call postOffice->Send with the request message
                        call postOffice->Receive to get the response message with lock index
                        return the index;
                }


                void DestroyLock_Syscall(unsigned int index) {        in exception.cc
                        create chars for request and response
                        set the outgoing packet and mail header
                        put the op code and lock index to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive an OK response from the server
                }


                void Acquire_Syscall(unsigned int index) {        in exception.cc
                        create chars for request and response
                        set outgoing packet and mail header
                        put op code and lock index into the request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive an OK response from the server
                }


                void Release_Syscall(unsigned int index) {        in exception.cc
                        create chars for request and response
                        set outgoing packet and mail header
                        put op code and lock index into the request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive a response from the server
                }


                int CreateCondition_Syscall(in vaddr, int size) {        in exception.cc
                        create chars for request and response
                        put op code and index into the request message
                        set outgoing packet and mail header
                        call postOffice->Send with request message
                        call postOffice->Receive to receive a response from the server
                }


                void DestroyCondition_Syscall(int index) {        in exception.cc
                        removed previous implementation
                        create chars for request and response message
                        set op code and index onto the request message
                        set packet and mail header
                        call postOffice->Send with request message
                        call postOffice->Receive to get response
                }


                void Wait_Syscall(int cvIndex, int lockIndex) {        in exception.cc
                        removed previous implementation
                        create chars for request and response message
                        put op code, cvIndex, and lockIndex onto the request message
                        set packet and mail header
                        call postOffice->Send with request mesesage
                        call postOffice->Receive to receive response from the server
                }


                void Signal_Syscall(int cvIndex, int lockIndex) {        in exception.cc
                        create chars for request and response
                        put opcode, CV index, and lock index into the request message
                        set outgoing packet and mail header
                        call postOffice->Send with request message
                        call postOffice->receive to get response from server
                }


void Broadcast_Syscall(int cvIndex, lockIndex) {        in exception.cc
                        create chars for request and response
                        set the outgoing packet and mail header
                        put the op code, CV index and lock index to request message
                        call postOffice->Send with request message
                        call postOffice->Receive to receive an OK response from the server


}


int main(int argc, char **argv) {        in main.cc
        added nachos -m # -Server to start the server
}




V. Testing:  (For each test case, you must show)
        + How to test
* To test multiprogramming and virtual memory using our new TLB and demand paged setup, from the vm directory call 
?nachos -x ../test/testexec -P <RAND or FIFO>?
?nachos -x ../test/sort -P <RAND or FIFO>?
?nachos -x ../test/matmult -P <RAND or FIFO>? 


*****SERVER TESTING*****
*To start the server, open a dedicated aludra process, navigate to the network directory, compile, and run ?nachos -server -m 0?


* To test the functionality of all RPCs (excluding Broadcast), from the network directory run: (must run in it?s own process, with server already running in a separate process)


* nachos -x ../test/locksandcvs -m 1
This user program will create two locks, called Lock1 and Lock2, two cv?s,
called CV1 and CV2, and one mv called MV1. The server (in its own
aludra process) will output that these have been created. This user
program will then end.


* Have 4 separate aludra processes from the server.
Enter each of the following commands in its own aludra processes.
To best do this part, type out each command before starting them.
(make sure to still be in the network directory)


                        * nachos -x ../test/test_locks -m 2
                        * nachos -x ../test/test_locks -m 3
                        * nachos -x ../test/test_locks -m 4
                        * nachos -x ../test/test_locks -m 5
                        
                        The first test_locks user program that you start will wait and not output
                        anything. After starting the second test_locks user program, the first will
                        run to completion while the second waits. After starting the third, the
                        second will finish while the third waits. Finally after starting the fourth,
                        both the third and fourth will finish.



*To test the functionality of the broadcast RPC, from the network directory run
(while the server runs in its own aludra process):


* nachos -x ../test/locksandcvs -m 1
NOTE: if you already ran the previous test and did not close the server
then you do not need to rerun this command as the locks and cvs will
already be created in the server. But if you closed the server or did not
already run this command you must run it to create them.


                        * Have at least 3 or 4 aludra processes open that are separate from the
server.


* In all but 1 of the aludra processes run the following:
nachos -x ../test/test_broadcast_wait -m 2
nachos -x ../test/test_broadcast_wait -m 3
nachos -x ../test/test_broadcast_wait -m 4
(only run the last if you have 4 aludra processes)


* Then in the last aludra process, AFTER you have started the above
user programs run the following:
nachos -x ../test/test_broadcast -m 5


* After running the test_broadcast user program, all the waiting user
programs should end.


+ Test Output
*testexec - You should see 3 return values: one will return 0 from main, and two will return  7220
*sort - You should see 1 return value, 1023
*matmult - You should see 1 return value 7220


* For the first rpc test involving the test_locks user program: After starting the first instance of the test_locks user program, it will simply wait. After starting the second instance, the first instance will output ?I have lock? and then ?MV is 0? and then ?I am releasing lock? before exiting with status 0. The second instance will wait until the third instance is started. Once the third instance is started, the second will finish with the same output as the first, but instead saying ?MV is 1?. The third instance will wait until the fourth is started. Finally once the fourth is started, the third will finish with the same output as the last but instead saying ?MV is 2?. The fourth will finish right after the third finishes (not waiting for a fifth) saying ?MV is 3?.


* For the broadcast rpc test: Upon starting the instances of the test_broadcast_wait user programs, they will not output anything and will instead simply wait. After starting the test_broadcast user program, each test_broadcast_wait user program will finish after outputting ?Done!? and ?Exit with status 0?. The test_broadcast user program will also finish without outputting anything except ?Exit with status 0?.


* NOTE: For both of the rpc tests, the server will output helpful information about what is happening internally whenever a nachos client user program makes a rpc.

VI. Discussion:
+ Experiment expectation.  (What is supposed to happen.)
*For testexec, all three processes should completely execute and return correct exit values (0, 7220, 7220)
*For the rpc tests, the processes should completely execute after all the steps have been taken, and the output should be as described above.
*For the rpc broadcast tests, the processes should completely execute after the test_broadcast user program runs, and then output should be as described above.
+ Experiment result.  (What actually happened.)
*For testexec, the processes returned the expected values
*For the rpc tests, the processes returned the expected values
*For the broadcast rpc tests, the processes returned the expected values
+ Explanation
        *For testexec, we exec two instances of matmult, which are both individually larger than our physical memory. Since we do not preload anything when starting nachos, in order for these programs to correctly execute, we must have properly implemented Demand Paged Virtual Memory.


*For the first rpc tests using the test_locks user program: Each user program uses shared locks, cvs, and mvs which were created by the locksandcvs user program prior to their running. Each test_locks instance acquires the shared lock (Lock1) from the server, gets the value of the shared mv (MV1) and stores it and then increments the value of the mv. After doing this, the instance then signals on the shared cv (CV1), so that if a prior instance is waiting it will be woken up. For the first instance to run, this signal will not do anything. Then after signalling, the test_locks instance will wait on the shared cv, giving up the shared lock, only to be woke up when the next test_locks instance signals on it as mentioned before. Once woken up, the instance will reacquire the shared lock and then print out ?I have lock?, followed by printing out the value of mv from when the instance began running. Then the instance will print out ?I am releasing lock?. The instance will check if it is the second last instance to run of the four by checking the value of the mv. If it is the second last instance, it will wake up the last instance by signalling on the shared lock and cv. The instance will then release the lock and end. Note that this test shows that 5 separate instances of nachos were able to communicate together through the server.


*For the broadcast rpc test: Each user program shares a lock (Lock2) and cv (CV2) which was created by the locksandcvs user program. The test_broadcast_wait user programs acquire the shared lock, and then wait on the shared cv using this shared lock. Then when the test_broadcast user program runs, it will acquire the shared lock and broadcast on the shared cv, waking all the sleeping test_broadcast_wait user programs.

VIII. Miscellaneous:

***We used vectors in this assignment, the grader should ensure that the includes in his machine directory are in the appropriate order to allow this***
According to Piazza post 156: https://piazza.com/class/idqhn1k3sfn267?cid=156, changing these includes to be able to use vectors is allowed.
-If there are compile errors, make the following changes:
*In interrupt.cc: line 23 #include <iostream> should be placed after #include "system.h"


*In machine.cc: line 12 #include "system.h" should be placed after #include "copyright.h" and before #include "machine.h"


*In mipssim.cc: line 17 #include "system.h" should be placed after #include "copyright.h" and before #include "machine.h"


*In translate.cc: line 35 #include "system.h" should be placed after #include "copyright.h" and before #include "machine.h"
