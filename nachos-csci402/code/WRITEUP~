 Title:  Writeup for Project 2, Fall 2015
 Date:  10/21/15
 Group:	Sloan Swieso	swieso@usc.edu	
	Rollin Baker	rollinba@usc.edu	
	Jiwoo Kim	jiwookim@usc.edu	
 
I. Requirements:

In Part 1, we implement system calls Fork, Exec, Exit, Yield, Acquire, Release, Signal, Broadcast, Wait, CreateLock, DestroyLock, CreateCondition, and DestroyCondition. Fork and   Exec will be completed in Part 2. Some files must be modified in order to add new system calls currently not existing in Nachos. Use already implemented page table and bitmap to find and map memory pages. Fork is starting a thread in an already existing process. Exec is starting a whole new process with an initial thread. Exit will turn off a thread or process determined by the number of thread and process. Yield is yield. All the lock and condition system calls are basically the same as they were before but instead treated as kernel?s global variable. 

Part 2 will implement multiprogramming. Allow multiple threads in a process as well as multiple stacks. Complete Exec and Fork system calls with multiprogramming. Test Fork and Exec to make sure multiprogramming is done correctly. Fork and Exec calls should add to the global process table to enable easier keeping track of processes and memory. Address space should allow multiprogramming in its constructor by making multiple stacks and finding empty memory with a bitmap.

In Part 3, we convert passport office simulation to a set of multithreaded user programs using the new Lock and Condition system calls we implemented in Part 1. Use Fork to create threads.  Test Exec by running multiple passport offices on their own processes at the same time. Prove our implementation of system calls with test suite.

II. Assumptions:
	We are assuming our memory is more or less unlimited. We have modified the ?machine? directory so that we have enough memory to execute a reasonable number of multithreaded processes.

III. Design:


System calls - 
System calls are the way that user programs can interact with the OS. When a syscall is used, an exception is raised within the OS that we ?trap?, and execute a particular function in the kernel based on the exception type. During the time after a syscall is invoked, there is a switch from ?user mode? to ?kernel mode? that allows the kernel to execute its own functions that the user program cannot call directly.
In system calls such as Fork, Exec, Exit, or any others where kernel variables are modified or looked at, mutual exclusion will be enforced through a designated kernel lock. For locks and conditions, the kernel will have a global table to keep track of all the locks and conditions so they can be accessed, added, or deleted in system calls.

Fork: First, check the process that needs to increment its thread number. Create a new thread and allocate its stack. Set the new thread?s space to be the current thread?s space. Now call the Thread::Fork on this new thread passing in a function called Fork_Thread. Fork_Thread will initialize registers and write to it the register values for PC, next PC, and stack. Then it runs machine->Run() to complete the fork.

Exec: Check for validity of the name first to either quit the function or continue on. If valid, Create a new OpenFile pointer variable and open it using fileSystem. Check the OpenFile validity. Now create a new address space associated with the OpenFile pointer as well as a new process and a thread. Set the thread?s space to be the new address space. Add the new process to the process table, and finally thread fork the new thread with Exec_Thread function. Exec_Thread is only going to initialize registers and run machine->Run().

Exit: If the thread that is not the last thread in the process calls Exit, reclaim the 8 pages of stack. If the last executing thread in the last process calls exit, shut the whole thing down with interrupt->Halt(). If the last executing thread in not last process calls Exit, reclaim all unreclaimed memory, iterate entire table with for loop, set the Lock and Condition pointer to null with process table. currentThread->Finish() must be included and any function that forks must also call Exit.

Yield: Yield the control over to the kernel. Call ?currentThread->Yield().

Acquire: Find the lock in kernelLockTable with the given index and acquire it.

Release: Find the lock in kernelLockTable with the given index and release it. In case if the releaser is the last thread on the lock, we can set the lock?s flags to false/null to get it ready to be deleted.

Signal: Find the condition in the kernelConditionTable with the given index, find the lock in the kernelLockTable with the other given index, then the condition will call Signal and pass in the lock. 

Wait: Find the condition and the lock in kernelTables with the given index and the condition will call Wait with the lock as an argument.

BroadCast: Find the condition and the lock in kernelTables with the given index and the condition will call Broadcast and pass in the lock as an argument.

CreateLock: Instantiates a new KernelLock* object and stores it in a vector contained in system.h. A KernelLock contains a Lock (from part 1), a pointer to the address space the lock is for, and a flag designating if the lock is to be deleted.

DestroyLock: Deletes a lock from the kernelLockTable with the given index if the lock is not in use. If the lock is in use, it will not be deleted at that time.

CreateCondition: Instantiates a new KernelCondition and stores it in a vector contained in system.h. 

DestroyCondition: Deletes a condition object with the given index if it is not in use.

GetID: return the integer ID of the current thread.

There are also other system calls such as Print or PrintInt to be able to print stuff out in the command window. These essentially just switch to kernel mode so that a simple library function can be called. These are the simplest of all the syscalls.

Multiprogramming

Change the addrspace so that the virtual and physical page in a page table are not equal. This can be achieved by using bitMap?s Find() function to find the available memory. However, if Find returns -1 (no availability), we will have to halt the program. When system call Fork is called, we can call another function allocateStack() to achieve multiple stacks. In this function, we add 8 pages to numPages since each stack is 8 pages long. We create a whole new page table and make it equal to the old page table, and the new 8 pages will be initialized normally like the constructor does. There will also be functions to clear the memory when Exit system call is called. They will either delete the stack for the thread or delete the whole program when process has no more threads.


Process table will be used to keep track of all the processes and their threads. The table will be a simple vector containing process pointers. 

Process struct
This struct simulates a process block and contains all the necessary attributes of a process. Its data members include a pointer to its address space, a vector of currently active threads, and a vector of ?pairs?. These pairs consist of the thread, and a pointer to the thread?s stack.

PageTable
An array of translation entries, we keep track of page tables with each element of the process table. The process block uses the page table to translate between virtual addresses seen by the user program and the actual location of that page in physical memory. The location of the physical page is determined by the next open slot returned by bitmap->Find().

Passport Office as Nachos user programs

Recreate all locks and conditions using the new System calls implemented in Part 1 earlier. Convert all classes to either void functions or structs. 

Throughout the project design, we ran into a number of race conditions and synchronization problems. As a result, a lock is required on nearly every kernel resource, since any of their services may be requested at any time by an arbitrary number of threads/processes. 

The locks we created: kernelLockLock, kernelCVLock, bitMapLock, processLock, and outputLock.
*The kernelLockLock is a lock used to gain access to the kernelLockTable. The kernelLockTable is what coordinates all of the locks requested by the user program through syscalls. Since any thread in the user program may attempt to modify the kernelLockTable at any time, the table must have a lock to avoid race conditions

*The kernelCVLock serves the same purpose as kernelLockLock, except it instead coordinates access to the table of condition variables kept by the kernel

*The bitMapLock synchronizes requests to the global bitmap that is used to allocate pages within memory. Obviously we must avoid race conditions here at all costs, so a lock is necessary

*The processLock is the lock on the process table. This is necessary because the processes have multiple threads that may be needed data allocated, which requires updating of the process page table.

*The outputLock is the lock so that the output in the Print() and PrintInt() syscalls do not get interrupted by another thread?s output.

IV. Implementation:
Throughout our implementation, we dealt with race conditions using the four locks above. When we needed to access bitMap, we enforced mutual exclusion through bitMapLock; when we accessed processTable, we used processLock, et cetera.

The passportoffice.c in test directory contains the passport codes as nachos user programs. All the classes such as customer and clerk have been converted to structs, all the locks and conditions have become integers controlled by a data structure called ClerkMutex, and data type has been limited to integer and char. ?bool? has been enum?ed to be available to use. Correct behavior for the passport office remains the same as the previous assignment. The last line from the program should be ?Manager is closing the Passport Office.? followed by the nachos halting messages.

	+ Files Modified	
		machine.h // to change number of pages
		syscall.h // to add the new system call functions
		exception.cc // to implement system calls
		system.h // to add kernel variables such as locks, conditions, bitmap, etc
		system.cc // assign kernel variables
		addrspace.h // new function declaration
		addrspace.cc // changes to constructor and a new function for stack
		progtest.cc // StartProcess modified
		Makefile // changes
		
		

	+ Files added (only testing cases were added)
passportoffice.c
passexec.c
exec.c
fork.c
lockandcvs.c
print.c
mp_lock.c
mp_wait.c
mp_broadcast.c
mp_signal.c


+ Data Structures added, and the file they were added to.
		struct Process {		in system.h
			Process(AddrSpace* _space) {
				space = _space
				numthreads = 1;
				threadStacks = new vector<pair<thread,stack>>
			}
			AddrSpace* space;
			int numThreads;
			declare threadStack
		}

		struct KernelLock {		in system.h
			KernelLock(char* name, AddrSpace* _addrspace) {
				lock = new lock(name)
				tobeDeleted = false;
				numThreads = 0;
				addrspace = _addrspace
				valid = true;
			}
			Lock* lock;
			AddrSpace* addrspace;
			bool tobeDeleted;
			bool valid;
			int numThreads;
		};

		struct KernelCondition {		in system.h
			KernelCondition(char* name, AddrSpace* _addrspace) {
				condition = new Condition(name);
				tobeDeleted = false;
				numThreads = 0;
				addrspace = _addrspace;
				valid = true;
			}
			Condition* condition;
			AddrSpace* addrspace;
			bool tobeDeleted;
			bool valid;
			int numThreads;
		};

		struct Customer { 			passportoffice.c
			int socialsecurity;
			int money
			char* name
		}

		struct Clerk {				passportoffice.c
			int id, money, linecount, bribelinecount, toFile;
			bool senatorInLine, picLiked;
			clerkState state;
		}

		struct ClerkMutex {			passportoffice.c
			int lineCV, bribeLineCV, senatorLineCV, clerkCV, clerkLock;
		}

		struct CustomerData {			passportoffice.c
			bool arrived, outside, social, picture, passport, paid;
		}


	+ Data Structures modified, and the file they were added to.
		class AddrSpace {			in addrspace.h/cc
			added new function AllocateStack() (details in next section)
			changed constructor (details in next section)
			added clearmem() and clearStack() for deallocation
			added getter for numPages
		}


	+ Functions added and in which file.
		functions that use kernel variables in any way will acquire/release the lock 
	void Fork_Thread(int vaddr) {			in exception.cc
		create a pair that contains a thread and its stack location
		add the pair to threadStacks vector of the correct process
		initialize registers and restore state
		Write to PC, next PC, and Stack register the correct values
		call machine->Run();
	}

	void Fork_Syscall(int addr, int vaddr, int size, int id) { in exception.cc
		increment the thread count on the corresponding process
		create a new thread
		allocate new stack for the thread
		set the new thread?s space to be the current thread?s space
		thread fork the new thread calling Fork_Thread
	}

	void Exec_Thread() {			in exception.cc
		initialize registers
		restore state
		machine->Run()
	}

	void Exec_Syscall(int vaddr, int size) {	in exception.cc
		check for the validity of file name
		make a new OpenFile variable and open it with given name
		check for OpenFile?s validity
		create a new address space associated with the new OpenFile
		create a new process and thread
		add the new process to process table
		make thread?s space be the new address space above
		add the pair of thread/stack to the process?s stack vector
		thread fork with Exec_Thread function to finish.
	}

	
void Exit_Syscall(int status) {			in exception.cc
		get the process associated with the exiter
		if number of threads is greater than 1
			decrement thread counter
			clear the stack for the thread
			delete the thread/stack pair
			delete the thread from the process
		else if the exiter is the last thread in process
			if it is the last process, interrupt->Halt().
			if not, clear the memory for the whole process
			destroy lock,condition, process, etc
	}

	int CreateLock_Syscall(unsigned int vaddr, int length) {	in exception.cc
		check for valid name of the lock
		create a new KernelLock instance with the name
		add this lock to kernelLocktable
		return kernelLockTalbe->size()-1
	}

	void Acquire_Syscall(int index) {		in exception.cc
		check for index validity
		get the lock given the index argument from the kernelLockTable
		acquire it
	}

	void Release_Syscall(int index) {		in exception.cc
		check for index validity
		get the lock with the index from kernelLockTable
		if lock is valid, release it
		if lock has no threads and is flagged to be deleted, delete it
	}

	void DestroyLock_Syscall(int idnex) {		in exception.cc
		get the lock with the given index and set its flags to null/false
		if no threads are waiting on it, delete the lock.
		else flag is read yto die
	}

	int CreateCondition_Syscall(unsigned int vaddr, int length) { in exception.cc
		create a new KernelCondition pointer variable with given name
		push this condition to the kernelConditionTable
		return kernelConditionTable->size()-1;
	}

	void Wait_Syscall(int lockIndex, int conditionIndex) {	in exception.cc
		check for lockindex and conditionIndex validity
		find the lock and condition given the index for each
		increment the thread counter on condition
			the found condition calls Wait with the found lock as an argument
		}

		void Signal_Syscall(int lockIndex, int conditionIndex) { in exception.cc
			check for lock and condition index validity
			find the lock and condition given the index for each
			the found condition calls Signal with the found lock as an argument
		}

		void Broadcast_Syscall(int lockIndex, int conditionIndex) { in exception.cc
			check for lock and condition index validity
			find the lock and condition given the index for each
			the found condition calls Broadcast with the found lock as an argument
		}

		void DestroyCondition_Syscall(int index) { in exception.cc
			check for index validity
			get the correct condition given the index
			make sure no threads are on the condition and set the flags to null/false
			set it ready to be deleted.
		}


		AllocateStack() { 		in addrspace.h/cc
			increase numPages by 8;
			create a new TranslationEntry* called newPageTable
			fill the newPageTable with the ?old? pageTable data with for loop
			fill the last 8 pages normally like in the constructor
			delete ?old? pageTable
			set the pageTable to be the newPageTable
		}

		void clearMem() {			in addrspace.h/cc
			for (i = 0 to numpages)
				bitmap clear the physical page of pagetable[i]
				set pagetable[i] valid bit to false
		}
	
	void clearStack(int stack) {			in addrspace.h/cc
		end = stack/pagesize;
		for (i = end-7 to stackend)
			bitmap clear the physical page of pagetable[i]
			set pagetable[i] valid bit to false
		}


	+ Functions modified and in which file.
	ExceptionHandler(ExceptionType which) {		in exception.cc
		// added the cases for every new system call we created
		case SC_Acquire:
			DEBUG(?a?, ?Acquire syscall.\n?);
			Acquire_Syscall(machine->ReadRegister(4));
			break
		case_SC_Release:
			DEBUG(?a?, ?Release Syscall.\n?);
			Release_Syscall(machine->ReadRegister(4));
			break
		case_SC_DestroyLock:
			DEBUG(?a?, ?Destroy Lock syscall.\n?);
			DestroyLock_Syscall(machine->ReadRegister(4));
			break;
		case_SC_CreateCondition:
			DEBUG(?a?, ?Create Condition syscall.\n?);
			rv = CreateCondition_Syscall(machine->reg(4), machine->reg(5));
			break;
		case_SC_Wait:
			DEBUG(?a?, ?Wait syscall.\n?);
			Wait_Syscall(machine->reg(4), machine->reg(5));
			break;
		case_SC_Signal:
			DEBUG(?a?, ?Signal syscall.\n?);
			Signal_Syscall(machine->reg(4), machine->reg(5));
			break;
		case_SC_BroadCast:
			DEBUG(?a?, ?Broadcast syscall.\n?);
			Broadcast_Syscall(machine->reg(4), machine->reg(5));
			break
		case_SC_DestroyCondition:
			DEBUG(?a?, ?Destroy Condition syscall.\n?);
			DestroyCondition_Syscall(machine->reg(4));
			break;
		case_SC_Fork:
			DEBUG(?a?, ?Fork syscall.\n?);
			Fork_Syscall(reg4,reg5,reg6,reg7);
			break;
		case_SC_Exec:
			DEBUG(?a?, ?Exec syscall.\n?);
			Exec_Syscall(machine->ReadRegister(4),reg(5));
			break;
		case_SC_Exit:
			DEBUG(?a?, ?Exit syscall.\n?);
			Exit_Syscall(reg(4));
			break;
		case_SC_Print,PrintInt,GetId, etc...
	}

	AddrSpace(OpenFile * executable) : fileTable(MaxOpenFiles){ in addrspace.cc
		assign pageTable?s physicalPage to bitMap->Find() instead of i;
		call ?interrupt->halt? in case the Find returns -1.
	}

	void Initialize(int argc, char **argv) {	in system.cc
		initialize kernel locks
		initialize kernel conditions
		initialize kernel variables such as memorymanager and bitmap
	}

	StartProcess(char *filename) 	{	in progtest.cc
		added more lines to actually create process in this function
		the process will get the initial thread and stack for threadStack vector
		process is added to processTable
	}

	
		


V. Testing:  (For each test case, you must show)
	+ How to test
*Testing our syscalls while loading multiple multithreaded programs will be the	
basis of our testing. By showing a particular set of syscalls can properly produce an acceptable output we will show that our multiprogramming and syscall code can sufficiently perform the required tasks.

*To test the Lock operations in multithreaded programs, from the userprog directory call 
?nachos -x ../test/mp_lock?
		*To test the Fork syscall, from the userprog directory call
			?nachos -x ../test/fork?
		*To test the Exec syscall, from the userprog directory call
			?nachos -x ../test/exec?
		*To test the Wait syscall, from the userprog directory call
			?nachos -x ../test/mp_wait
		*To test the Signal syscall, from the userprog directory call
			?nachos -x ../test/mp_signal?
		*To test the Broadcast syscall, from the userprog directory call
			?nachos -x ../test/mp_broadcast?
		*To test the passport office program, from the userprog directory call
			?nachos -x ../test/passportoffice?
*To test multiple passport office programs, from the userprog directory call
	?nachos -x ../test/passexec?

+ Test Output
	For the lock test output, the screen should print ?12? followed by a newline ten times, this indicates a successful test
Fork test should print out ?CSCI350\nOS\n? or ?OS\nCSCI350\n? details below
Exec test should print out strings ?CSCI350\n?, ?OS\n?, ?Hello World\n? in any order
Wait test should print out nothing and machine halts.
Signal test should print out ?hi\n?
Details on the output are explained in the Discussion section below.


VI. Discussion:
	+ Experiment expectation.  (What is supposed to happen.)
		?nachos -x ../test/mp_lock? should print:
			12
			12
			12
			12
			12
			12
			12
			12
			12
		
		?nachos -x ../test/fork? should print:
			?CSCI 350
			OS? or 
			?OS
			CSCI 350?
		?nachos -x ../test/exec? should print:
			?Hello World
			CSCI 350
			OS? 
			the order of strings above will be random

		?nachos -x ../test/mp_wait? should print nothing

		?nachos -x../test/mp_signal? should print:
??Signal Success!?

?nachos -x ../test/mp_broadcast? should print:
	?Broadcast Success!?
	?Broadcast Success!?
	?Broadcast Success!?

For the passport office simulations, as long as the passport office terminates (with meaningful output), then it ran correctly. 
			

	+ Experiment result.  (What actually happened.)
*See above section, all outputs of the tests were as expected for every value of ?rs? we tried

	+ Explanation
		?nachos -x ../test/mp_lock?
*20 different threads are forked from the main process. Before every function call, main needs to acquire the lock. This means that every loop iteration will spawn two threads, the first will print ?1? and the second will print ?2\n? in that order every time. The locks ensure the order of execution so the output from the previous section indicates a successful test

		?nachos -x ../test/fork?
			function print1() prints out ?CSCI 350\n?, and print2() prints out ?OS\n?
			main function Forks print1, then print2
		?nachos -x ../test/exec?
			main calls Exec on ../test/fork, and then on ../test/print.
			fork, like explained above, prints out ?CSCI\nOS\n?
			print prints ?Hello World?
			exec test will print out 3 strings in any order
			our result above is good
		?nachos -x ../test/mp_wait?
			this test file has an integer, condition variable, and a lock.
			in the main, we system Fork another function called increment
			increment() acquires lock, increments i, waits on the CV, then prints out.
			since nothing ever calls signal, print line will never be reached.
			therefore, nothing will be printed out.

		?nachos -x ../test/mp_signal?
*A function is forked from the main thread, and the main thread waits on a condition variable
*The dummy function then signals on the condition variable, and the main thread prints a success message and terminates
*If signal did not wake up a waiting thread, the main thread would never terminate, so this indicates a successful test

		?nachos -x ../test/mp_broadcast?
*Three function is forked from the main thread, and all three forked threads waits on the same condition variable
*The main thread then signals on the condition variable once all three threads, and each forked thread prints a success message and terminates
*If broadcast did not wake up all waiting threads, the messages would never print and the threads would never terminate, so this indicates a successful test

It should be noted that the Wait, Signal, and Broadcast syscalls all depend on correct implementations of all condition variable syscalls, so correct execution of the above syscalls implies correct CV syscalls		
			


VIII. Miscellaneous:

Our functions of passportoffice.c have changed due to the conversion but they function identically as they did in project 1. Therefore, little changes to the functions were not documented in the implementation section.

The locks in passportoffice.c and their purposes:
*lineLock: the lock so that any operation including choosing a line remains atomic.
*moneyLock: the lock so that clerks do not acquire more money while the manager counts money.
*senatorLock: the lock to ensure that only one senator is present at a time.
*outsideLock: the lock to the ?front door? of the office, so that customers must wait outside while a senator is present.
*outputLock: the lock to ensure that output remains grouped together within a single passportoffice process. Note - when running multiple passportoffice processes, their outputs are mixed together.


